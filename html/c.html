<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C语言</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax:{
        inlineMath: [["\\(", "\\)"]],
        displayMath: [['$$','$$'],["\\[","\\]"]],
        processEscapes: true
    },
    "HTML-CSS": {fonts: ["TeX"]},
    TeX: {
        extensions: ["AMSmath.js", "AMSsymbols.js", "noErrors.js", "noUndefined.js"],
        equationNumbers: {autoNumber: "all"},
    }
});
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('c.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">C语言 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><hr/>
 <h1><a class="anchor" id="预编译篇"></a>
预编译篇</h1>
<hr/>
 <h2><a class="anchor" id="sharp_in_macro"></a>
宏定义中的#</h2>
<p># （stringizing）是字符串化操作符。其作用是：将宏定义中的传入参数名转换成用一对双引号括起来参数名字符串。 其只能用于有传入参数的宏定义中，且必须置于宏定义体中的参数名前。</p>
<p>如：</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define PRINT(instr) printf(&quot;the input string is:/t%s/n&quot;,#instr)</span></div><div class="line"><span class="preprocessor">#define CONVERT(instr) #instr</span></div><div class="line">PRINT(abc)；  <span class="comment">// 在编译时将会展开成：printf(&quot;the input string is:/t%s/n&quot;,&quot;abc&quot;);</span></div><div class="line"><span class="keywordtype">string</span> str=CONVERT(abc)； <span class="comment">// 将会展成：string str=&quot;abc&quot;；</span></div></div><!-- fragment --><p>注意其对空格的处理</p>
<p>1.忽略传入参数名前面和后面的空格。</p>
<p>如：str=FUNC1(   abc )； 将会被扩展成 str="abc"；</p>
<p>b.当传入参数名间存在空格时，编译器将会自动连接各个子字符串，用每个子字符串中只以一个空格连接，忽略其中多余一个的空格。</p>
<p>如：str=exapme( abc    def); 将会被扩展成 str="abc def"；</p>
<hr/>
 <h2><a class="anchor" id="sharp_in_macro"></a>
宏定义中的#</h2>
<p>## （token-pasting）符号连接操作符</p>
<p>宏定义中：参数名，即为形参，如::define sum(a,b) (a+b)；中a和b均为某一参数的代表符号，即形式参数。</p>
<p>而##的作用则是将宏定义的多个形参成一个实际参数名。</p>
<p>如：</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define NUM(n) num##n</span></div><div class="line"><span class="keywordtype">int</span> num9=9;</div><div class="line"><span class="keywordtype">int</span> num=NUM(9); 将会扩展成 <span class="keywordtype">int</span> num=num9;</div></div><!-- fragment --><p>注意：</p>
<p>1.当用##连接形参时，##前后的空格可有可无。</p>
<p>如：::define NUM(n) num ## n 相当于 #define NUM(n) num##n</p>
<p>2.连接后的实际参数名，必须为实际存在的参数名或是编译器已知的宏定义</p>
<hr/>
 <h1><a class="anchor" id="编译篇"></a>
编译篇</h1>
<hr/>
 <h2><a class="anchor" id="如何将可变长度参数传入printf"></a>
?</h2>
<p>前言：函数A接收可变长参数，有的时候我们希望把可变长的参数直接传入函数A内部的sprintf和printf， 即我既想把输出保存起来，也想同时打印到屏幕，该如何操作呢？</p>
<p>方法：如下代码所示，vfprintf也可以改成vsprintf或者vsnprintf。</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Error(<span class="keyword">const</span> <span class="keywordtype">char</span>* format, ...)</div><div class="line">{</div><div class="line">    va_list argptr;</div><div class="line">    va_start(argptr, format);</div><div class="line">    vfprintf(stderr, format, argptr);</div><div class="line">    va_end(argptr);</div><div class="line">}</div></div><!-- fragment --><hr/>
 <h2><a class="anchor" id=""></a>
</h2>
<p>将在线代码分离成离线代码的时候，发现有些文件里面定义了_Bool类型，而gcc编译器居然不识别。 Google后发现，_Bool类型是C语言的布尔类型，从C99才开始引入的。 C99以前的C语言都是用int或者枚举的野路子来表示布尔型。。。 我们平时用的bool都是C++的东西。。。 也就是说如果在 extern "C"中间使用bool，是不被支持的，除非引用了头文件stdbool.h</p>
<hr/>
 <h2><a class="anchor" id="将指针赋值给uint32_t"></a>
将指针赋值给uint32_t</h2>
<p>很多32位平台的程序喜欢使将指针赋值给整数，这样就不需要二级指针，例如</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> func(uint32_t *addr)</div><div class="line">{</div><div class="line">  <span class="keywordtype">void</span> * data = malloc (1000);</div><div class="line">  *addr = (uint32_t) data;</div><div class="line">}</div></div><!-- fragment --><p> 如果需要在函数里面开内存，输出内存地址，那么要么使用二级指针，要么用这种转地址的方式。 但是，这种方式其实并不好，在64位系统中，指针的大小可能是64位的，这样赋值就会出错。 仍然像想用这种方式的话，使用intptr_t类型，兼容32和64位，在C99中支持，在&lt;stdint.h&gt;中定义。</p>
<hr/>
 <h2><a class="anchor" id="designated_initializer"></a>
designated initializer</h2>
<p>C语言中结构体在C99中的一种新的初始化语法，叫做designated initializer，即指定初始化，之前我一直找不到正式的名称，我一直称之为点变量初始化。。。</p>
<div class="fragment"><div class="line">MY_TYPE a = { .flag = <span class="keyword">true</span>, .value = 123, .stuff = 0.456 };</div></div><!-- fragment --> <div class="fragment"><div class="line">type <span class="keyword">struct</span></div><div class="line">{</div><div class="line">  <span class="keywordtype">int</span> a1;</div><div class="line">  <span class="keywordtype">float</span> a2;</div><div class="line">}A;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></div><div class="line">{</div><div class="line">  A sa;</div><div class="line">  <span class="keywordtype">int</span> b1;</div><div class="line">  <span class="keywordtype">float</span> b2;</div><div class="line">}B;</div><div class="line">B bs[2] = </div><div class="line">{</div><div class="line">  {</div><div class="line">    {</div><div class="line">      a1 = 0,</div><div class="line">      a2 = 0.0,</div><div class="line">    }</div><div class="line">    b1 = 0,</div><div class="line">    b2 = 0.0,</div><div class="line">  },</div><div class="line">  {</div><div class="line">    {</div><div class="line">      a1 = 1,</div><div class="line">      a2 = 1.0,</div><div class="line">    }</div><div class="line">    b1 = 1,</div><div class="line">    b2 = 1.0,</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p> 这个东西与编译器无关，是C99的标准，gcc想用的话必须开启选项 -std=c99</p>
<p><b>注意，这是C语言的语法，不是C++的语法，至少c++11还没有包含，在C++代码中不要混用！</b> 如果使用qtcreator构建工程，那么默认使用g++编译，然而如果designated initializer语句是在cpp文件里，g++是不支持的，不管CXX_FLAG 是不是加了c++11，或者C_FLAG 加了99，或者加入extern "C"，都不行， extern "C"只是指示c++编译器把函数编成C语言可识别的符号表，并不支持这种赋值语法。</p>
<p>但是我发现了一种方法，就是强行改cpp后缀为c，这样g++就会调用gcc来编译c文件。</p>
<hr/>
 <h2><a class="anchor" id="代码区分不同操作系统"></a>
代码区分不同操作系统</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#ifdef __linux__ </span></div><div class="line">    <span class="comment">//linux code goes here</span></div><div class="line"><span class="preprocessor">#elif _WIN32</span></div><div class="line">    <span class="comment">// windows code goes here</span></div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    cout&lt;&lt;<span class="stringliteral">&quot;OS not supported!&quot;</span>&lt;&lt;endl;</div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><hr/>
 <h2><a class="anchor" id="printf_red"></a>
如何打印红色字符串？</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include&lt;stdarg.h&gt;</span></div><div class="line">...</div><div class="line">void printf_red(<span class="keyword">const</span> <span class="keywordtype">char</span> *cmd, ...)  </div><div class="line">{  </div><div class="line">    printf(<span class="stringliteral">&quot;\x1B[31m&quot;</span>);  <span class="comment">//设置输出为红色</span></div><div class="line">    va_list args;       <span class="comment">//定义一个va_list类型的变量，用来储存单个参数  </span></div><div class="line">    va_start(args,cmd); <span class="comment">//使args指向可变参数的第一个参数  </span></div><div class="line">    vprintf(cmd,args);  <span class="comment">//必须用vprintf等带V的  </span></div><div class="line">    va_end(args);       <span class="comment">//结束可变参数的获取  </span></div><div class="line">    printf(<span class="stringliteral">&quot;\x1B[0m&quot;</span>)   <span class="comment">// 回到默认设置</span></div><div class="line">}  </div></div><!-- fragment --><hr/>
 <h2><a class="anchor" id="printf"></a>
中的uint64整数</h2>
<p>使用printf过程中，一定要写对字符串，之前遇到过一个问题，使用d来打印一个int64的数是错误的，例如下列代码</p>
<div class="fragment"><div class="line">uint64_t a = 1000;</div><div class="line">printf(<span class="stringliteral">&quot;%d\n&quot;</span>,a); <span class="comment">// 错误</span></div></div><!-- fragment --><p> 实际上，u，ld，lu都不对，在曾经一个ARM平台编译器上，正确的结果是llu，因为在该平台上，sizeof(long)=sizeof(int)=4，而uint64_t真正的类型是long long，在不同平台时，要注意类型字节数可能不一样。</p>
<hr/>
 <h2><a class="anchor" id="linux-arm-gcc"></a>
中的char默认是unsigned char!!!</h2>
<p>好可怕，给char类型变量赋值一个负数，会得到错误的结果，而且编译器不会报错或者警告 只有使用==判别时才提出警告。</p>
<div class="fragment"><div class="line">char a = -1;</div><div class="line">printf(&quot;%d\n&quot;,a );  //打印出 255</div><div class="line">if(a == -10)</div><div class="line">  printf(&quot;error&quot;) // 编译报错</div></div><!-- fragment --><hr/>
 <h2><a class="anchor" id="extern"></a>
声明</h2>
<p>默认的全局变量都开放成全局可用变量，其他模块想用该变量只需要extern声明即可。 例如a.c文件中定义int a = 0; b.c文件中声明extern int a; 那么b文件中使用的变量其实就是a文件中的变量 **a.c文件和b.c文件不需要什么相互依赖的关系，也和头文件无关**。 但是一般来说，在a.h中声明extern int a;然后b.c文件再include a.h文件，这样的用法会比较规范。</p>
<hr/>
 <h2><a class="anchor" id="multiple"></a>
definition?</h2>
<ol type="1">
<li>函数重复定义了，如果非要使用同名函数，加入static修饰符，只供本地函数使用。</li>
<li>头文件没有加入::ifdef #define #endif保证内容只定义一次。</li>
<li>前两个条件都没问题，仍然报这问题？查看一下有没有在头文件中定义变量？如果定义了变量，那么该头文件被多次include的时候，变量会重复的定义，解决的办法有两种，第一种，直接使用static修饰变量，那么h文件中的变量，就会在include的时候变成c文件的static变量，自然不会有冲突，第二种就是定义函数替代变量，函数里再定义这个全局变量，按理说全局变量本就应该使用函数访问。</li>
</ol>
<hr/>
 <h2><a class="anchor" id="unresolved"></a>
external symbol？</h2>
<p>如果这个symbol在源文件里：</p><ul>
<li>看看这个源文件有没有被加到工程中。</li>
<li>symbol在源文件中，并且已经添加到了工程，还会报这个错？看看是不是调用了.c文件，记得用EXTERN C封装，即在c文件函数声明的地方使用 <div class="fragment"><div class="line"><span class="preprocessor">#ifdef __cplusplus__</span></div><div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span>{</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"><span class="keywordtype">int</span> my_c_function();</div><div class="line"><span class="preprocessor">#ifdef __cplusplus__</span></div><div class="line">}</div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --></li>
<li>都是cpp文件或者c文件，或者已经用EXTERN C封装了，还会出错？看看是不是不同源文件字符编码的问题。</li>
<li>以上条件都满足，但在qtcreator中刚添加的函数还是报这个错？那就试着显式地qmake一下，然后再rebuild。</li>
</ul>
<p>如果这个symbol在库文件中：</p><ul>
<li>看看这个库有没有添加到工程。</li>
<li>库已经添加到工程，但是仍然报这个错？那就将库的版本和当前编译器版本保持一致，包括平台（x86或者x64）和版本（vc08，vc10，vc12，vc14）以及是否调试（debug和release）。</li>
</ul>
<hr/>
 <h2><a class="anchor" id="工程内外的头文件区别？"></a>
工程内外的头文件区别？</h2>
<p>C语言头文件不管是放在工程内部还是工程外部都可以include，那么这两种方式有什么区别呢？ 目前发现的区别有一点，就是工程内部的头文件内部再include别的头文件的时候可以享用工程文件已经添加的路径。 举个例子，a.h是工程部内的，b.h是工程外部的，main.cpp里面把这两个头文件都include了，工程pro（qtcreator）文件里包含了opencv的库目录。 那么打开a.h时输入“include &lt;opencv.....”，此时creator会自动补全，但是在b.h中输入则没有任何反应，这就是目前发现的一个区别。 但是我估计实际编译的时候应该没有问题，这只是IDE的识别问题而已。</p>
<hr/>
 <h2><a class="anchor" id=""></a>
</h2>
<p>在c文件中include Opencv的hpp头文件就会出现这个问题，因为编译c文件时是使用C编译器编译的，而.c文件是不认识.hpp文件的，实现的方式就是c编译器并未定义__cplusplus宏。按照道理说c文件不应该包含hpp文件，最好把c文件改成cpp文件。如果硬是不改，在VisualStudio中可以设置compile as c++。</p>
<hr/>
 <h2><a class="anchor" id="头文件重复包含"></a>
头文件重复包含</h2>
<p>我们都知道头文件一开始两行都是::ifndef和::define，是为了避免头文件重复包含，从逻辑上和减少编译时间看，都需要消除这种重复包含， 那么消除重复包含的工作为什么不丢给程序员做呢？</p><ol type="1">
<li>这样的工作非常枯燥而繁琐，包含的链路太长的话，光是找到公共头文件节点就很麻烦；</li>
<li>更重要的是，部分模块常常需要独立运行，这种冗余保证了模块也能够独立地运行。</li>
</ol>
<hr/>
 <h2><a class="anchor" id="utf-8文件的bom字节"></a>
utf-8文件的bom字节</h2>
<p>很蛋疼，读utf-8文件前面3个字节都不是文件中的内容，而是0xef,0xbb,0xbf，后来一查，发现这是utf-8文件的bom字节，就是byte order mark, 读utf-8文件时，一定要去掉前面三个字节。</p>
<hr/>
 <h2><a class="anchor" id="utf-8文件中的行结尾"></a>
'\r'</h2>
<p>很蛋疼+1，读utf-8文件的时候，行结尾都是以''结束， 当文件内容是另一个文件的路径的时候，例如 </p><div class="fragment"><div class="line">/mnt/cc/随便</div></div><!-- fragment --><p> 其实这一行读出来是这样的 </p><div class="fragment"><div class="line">&#39;/&#39;,&#39;m&#39;,&#39;,&#39;t&#39;,&#39;/&#39;,&#39;c&#39;,&#39;c&#39;,&#39;/&#39;,&#39;随,&#39;便&#39;,\r</div></div><!-- fragment --><p> 我一般喜欢在文件路径后面加上'/'，方便后面读取。 但是如果在后面加上'/'就会搞错。。</p>
<hr/>
 <h2><a class="anchor" id="qtcreator中开启gcc的c99支持"></a>
qtcreator中开启gcc的c99支持</h2>
<div class="fragment"><div class="line">QMAKE_CFLAGS += -std=c99</div></div><!-- fragment --><hr/>
 <h1><a class="anchor" id="库函数篇"></a>
库函数篇</h1>
<h2><a class="anchor" id="FLT_EPSILON宏"></a>
FLT_EPSILON宏</h2>
<p>问题：做除法的时候，我们知道分母不能为0，那么如何检查呢？ “if(a!=0.0f)”这种小学生的错误就不要犯了。</p>
<p>解决方法：一般来说我们需要拿到一个很小的数，如果分母的绝对值小于这个数，就认为分母为零。 最适合的方法是使用&lt;float.h&gt;提供的FLT_EPSILON。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;float.h&gt;</span></div><div class="line"><span class="keywordtype">float</span> a = 0;</div><div class="line"><span class="keywordflow">if</span>(fabs(a)&lt;FLT_EPSILON){</div><div class="line">  <span class="comment">// return error.</span></div><div class="line">}</div></div><!-- fragment --><hr/>
 <h1><a class="anchor" id="性能篇"></a>
性能篇</h1>
<hr/>
 <h2><a class="anchor" id="一个float不够用的例子"></a>
一个float不够用的例子</h2>
<p>x = {3137995, 3137895, 3137978} A = {{x0*x0, x0, 1},{x1*x1, x1, 1},{x2*x2, x2, 1}}</p>
<hr/>
 <h2><a class="anchor" id="下采样拷贝时间"></a>
下采样拷贝时间</h2>
<p>下采样拷贝虽然点数少，但是需要多次拷贝操作，那么这种方式和全拷贝速度差异如何呢？</p>
<div class="fragment"><div class="line">uint32_t W=640, H=480, WH=W*H;</div><div class="line">FILE *f = fopen(<span class="stringliteral">&quot;img&quot;</span>,<span class="stringliteral">&quot;rb&quot;</span>);</div><div class="line">uint8_t* buf = malloc(WH);</div><div class="line">fread(buf, WH, 1, f);</div><div class="line"></div><div class="line">int64_t t = cv::getTickCount();</div><div class="line">uint8_t * img = (uint8_t*) malloc(WH);</div><div class="line">memcpy(img, buf, WH);</div><div class="line">t = cv::getTickCount() - t;</div><div class="line">cout&lt;&lt;t/cv::getTickFrenquency()&lt;&lt;endl;</div><div class="line"></div><div class="line">t = cv::getTickCount();</div><div class="line">uint32_t sd=5, Wd=W/sd, Hd=H/sd;</div><div class="line">uint8_t *img_d = (uint8_t*)malloc(Wd*Hd);</div><div class="line"><span class="keywordflow">for</span>(uint32_t r=0; r&lt;Hd; r++)</div><div class="line">  <span class="keywordflow">for</span>(uint32_t c=0; c&lt;Wd; c++)</div><div class="line">    img_d[r*Wd+c] = buf[r*sd*W+c*sd];</div><div class="line">t = cv::getTickCount()-t;</div><div class="line">cout&lt;&lt;t/cv::getTickFrequency()&lt;&lt;endl;</div></div><!-- fragment --><p> PC上运行的结果，t1是全拷贝的时间，t2是下采样拷贝的时间，可以看到在debug版本中，2倍采样和3倍采样时间都要长于全采样，直到4倍采样开始时间才小于全采样，这是因为下采样需要设计循环，依次赋值，全拷贝肯定在汇编层面做了优化的。 有意思的是在Release版本中，2倍采样的时间就小于全拷贝，这就说明debug版本对于循环有着更深的影响，下采样最大运行时间相差了接近6倍。</p>
<p>Debug版本</p>
<table class="doxtable">
<tr>
<th>sd </th><th>1 </th><th>2 </th><th>3 </th><th>4 </th><th>5 </th><th>6  </th></tr>
<tr>
<td>t1 </td><td>91.5 </td><td>90.5 </td><td>91.7 </td><td>91.2 </td><td>90.4 </td><td>90.6 </td></tr>
<tr>
<td>t2 </td><td>840 </td><td>219 </td><td>102 </td><td>60.2 </td><td>39.1 </td><td>27.6 </td></tr>
</table>
<p>Release版本</p>
<table class="doxtable">
<tr>
<th>sd </th><th>1 </th><th>2 </th><th>3 </th><th>4 </th><th>5 </th><th>6  </th></tr>
<tr>
<td>t1 </td><td>74.4 </td><td>72.7 </td><td>74.3 </td><td>74.6 </td><td>77.3 </td><td>75.1 </td></tr>
<tr>
<td>t2 </td><td>158 </td><td>62.6 </td><td>30.5 </td><td>18.5 </td><td>12.3 </td><td>8.96 </td></tr>
</table>
<p>ARM </p><table class="doxtable">
<tr>
<th>sd </th><th>1 </th><th>2 </th><th>3 </th><th>4 </th><th>5 </th><th>6  </th></tr>
<tr>
<td>t1 </td><td>644 </td><td>654 </td><td>652 </td><td>645 </td><td>670 </td><td>685 </td></tr>
<tr>
<td>t2 </td><td>667 </td><td>208 </td><td>97.6 </td><td>28.2 </td><td>69.0 </td><td>48.4 </td></tr>
</table>
<hr/>
 <h2><a class="anchor" id="浮点转定点中的四舍五入"></a>
浮点转定点中的四舍五入</h2>
<p>浮点数转定点数不能直接截取，必须四舍五入，否则精度会丢失，有时候会丢失很多！ 例如下面的代码，将浮点数转换成16Q8的定点数，当输入0.035时，0.035*256.0=8.96，直接截取就变成了8，然而8对应着0.03125，9对应着0.03515625，很明显应该是9更合适。 我们自然而然地想到+0.5，例如第二行代码所示，但是这样仍然是有问题的，就是在使用负数的时候。 例如输入-0.6，那么照理说-0.6更接近-1，然而-0.6+0.5=-0.1会截取成0，没有错(int)(-0.1)=0，在VS下是这样的。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define Q168_FROM_FLOAT(x) ( (int16_t)((x)*256.0) ) // 丢失精度</span></div><div class="line"><span class="preprocessor">#define Q168_FROM_FLOAT(x) ( (int16_t)((x)*256.0+0.5) ) // 负数不准</span></div><div class="line"><span class="preprocessor">#define Q168_FROM_FLOAT(x) ( (int16_t)((x)&gt;=0?(x)*256.0+0.5:(x)*256.0-0.5) ) //完美</span></div><div class="line"></div><div class="line"><span class="comment">// 测试</span></div><div class="line">printf(<span class="stringliteral">&quot;%d,%d\n&quot;</span>, Q168_FROM_FLOAT(0.35), Q168_FROM_FLOAT(-0.35))</div><div class="line"><span class="comment">//结果为 9和-9，正确！</span></div></div><!-- fragment --><hr/>
 <h1><a class="anchor" id="代码规范篇"></a>
代码规范篇</h1>
<hr/>
 <h2><a class="anchor" id="全局变量用处"></a>
全局变量用处</h2>
<p>1.静态表格常量 2.调试系统</p>
<p>调试系统是反封装的，调试系统往往需要获取某些很深的函数内部的某些中间变量，如果通过传参获取， （1）那么函数参数就会很多， （2）调试系统需要查看的变量集可能会经常变化，层层递归修改函数形参。</p>
<hr/>
 <h2><a class="anchor" id="C语言算法中的数学参数放在哪里？"></a>
C语言算法中的数学参数放在哪里？</h2>
<p>程序运行过程中始终不变的数学常量称为参数，做算法的代码会有特别多的参数，要怎么放置这些参数呢？</p><ol type="1">
<li>直接在调用的地方用数字常量表示，例如 <div class="fragment"><div class="line">x = 0.01 *y;</div></div><!-- fragment --> 这种方式被称为magic number, 不太好。 第一，不好理解，如果只有一个number，还勉强可以注释，如果一行代码有多个number，就真的不好注释了。 第二，如果这个参数在很多地方用到，参数变动的时候，需要多处修改，非常容易有漏网之鱼。</li>
</ol>
<p>2.直接用宏来define数字，在调用的地方使用宏。 </p><div class="fragment"><div class="line"><span class="preprocessor">#define SLAM_PARA_XXXX 0.01</span></div></div><!-- fragment --><p> 这种方式比直接用数字要好，define单个数字是没问题的，但是在定义数组型参数的时候就不太方便了，例如 </p><div class="fragment"><div class="line"><span class="keywordtype">float</span> para_xxx[2][3] = {{1.0000, 2.0000, 3.0000},</div><div class="line">                        {4.0000, 5.0000, 6.0000}};</div></div><!-- fragment --><p> 一个很勉强的方式就是把宏定义成花括号里的内容，然后就在调用的地方新建一个变量=宏，但是这样很怪。。。 而且如果这个参数表很大的话，例如10x10的静态查找表，每次调用的地方新建变量并赋值一次会有很多额外消耗。</p>
<ol type="1">
<li>用全局变量直接定义 这种方式算是一种比较整洁的解决方案，但是全局变量用多了之后</li>
</ol>
<hr/>
 <h1><a class="anchor" id="实用代码片段"></a>
实用代码片段</h1>
<hr/>
 <h2><a class="anchor" id="彩色规范打印"></a>
彩色规范打印</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#indef PRINT_ERROR</span></div><div class="line"><span class="preprocessor">#define PRINT_ERROR(...)    \</span></div><div class="line"><span class="preprocessor">  do{                       \</span></div><div class="line"><span class="preprocessor">    printf(&quot;\x1B[41;37m&quot;);  \</span></div><div class="line"><span class="preprocessor">    printf(&quot;[ERROR]&quot;);      \</span></div><div class="line"><span class="preprocessor">    printf(&quot;\x1B[0m&quot;);      \</span></div><div class="line"><span class="preprocessor">    printf(__VA_ARGS__);    \</span></div><div class="line"><span class="preprocessor">    }                       \</span></div><div class="line"><span class="preprocessor">  while(0)</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#ifndef PRINT_INFO</span></div><div class="line"><span class="preprocessor">#define PRINT_INFO(...)     \</span></div><div class="line"><span class="preprocessor">  do{                       \</span></div><div class="line"><span class="preprocessor">    printf(&quot;\1xB[42;37m&quot;);  \</span></div><div class="line"><span class="preprocessor">    printf(&quot;[INFO] &quot;);      \</span></div><div class="line"><span class="preprocessor">    printf(__VA_ARGS__);    \</span></div><div class="line"><span class="preprocessor">    }                       \</span></div><div class="line"><span class="preprocessor">  while(0)</span></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><hr/>
 <h2><a class="anchor" id="头文件多次包含于只展开一次矛盾？"></a>
头文件多次包含于只展开一次矛盾？</h2>
<p>写代码的时候发现一个“问题”，我们一般用::ifdef包裹头文件，保证头文件只展开一次，否则会出现重复定义。 那么多个c文件包含同一个头文件时，后面的c文件是否就无法获取h文件里的内容了呢？ 当然，通过实际编程经验，我们都知道答案是否定的，但是怎么解释呢？ 我自己的解释是，头文件展开过程和c文件包含h文件过程是两码事，头文件展开在第一次被c文件包含的时候进行，之后再次被c文件包含时，就不在进行，而是仅仅拷贝h文件已经展开的内容。</p>
<hr/>
 <h2><a class="anchor" id="宏在c文件中的作用域"></a>
宏在c文件中的作用域</h2>
<p>宏定义有时候不一定会在c文件中起作用，如下面的例子所示。 main.c依赖a.h和a.c，而a.h又依赖b.h，所以我们自然而然的认为在main.c里包含a.h之前加入某一个宏，它能够在a.h和b.h都生效。 在头文件中，这是没有问题的，但是对于b.c文件，就不管用了（实际工作碰到的例子），因为b.h和b.c在编译的时候他们并不依赖其他模块，所以有可能b模块比main编译的时刻还要早（编译成obj文件），另外，如果仅仅是修改了宏，a.h和a.c的内容不会改变，那么a.o根本就不会重新发生编译。 </p><div class="fragment"><div class="line"><span class="comment">// main.c</span></div><div class="line"><span class="preprocessor">#define TURN_OFF_DEVIL</span></div><div class="line"><span class="preprocessor">#include &lt;a.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// a.h</span></div><div class="line"><span class="preprocessor">#include &lt;b.h&gt;</span></div><div class="line"><span class="preprocessor">#ifndef TUNN_OFF_DEVIL</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> i_am_devel_1;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="comment">// b.h</span></div><div class="line"><span class="comment">// b.c</span></div><div class="line"><span class="preprocessor">#include &lt;b.h&gt;</span></div><div class="line"><span class="preprocessor">#ifndef TURN_OFF_DEVIL</span></div><div class="line"><span class="keywordtype">int</span> i_am_devel2;</div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p> 解决方法，使用编译工具的宏定义工具，例如cmake的 </p><div class="fragment"><div class="line">target_compile_definitions(my_exe PRIVATE USE_SOMTHING=1)</div></div><!-- fragment --><hr/>
 <h2><a class="anchor" id="万不得已修改第三方代码怎么注释？"></a>
万不得已修改第三方代码怎么注释？</h2>
<p>这种情况通常出现在两个第三方库之间有命名冲突，例如都存在某一些数学函数。 注释方法： </p><div class="fragment"><div class="line"><span class="comment">// Hacked by somebody</span></div><div class="line"><span class="comment">// End of Hacking</span></div></div><!-- fragment --><p> 用“hack”这个词非常好，既能够表达出这是对原有模块的破坏，一眼就能看出hack了那些地方，原来是什么代码，另外也很容易搜索。</p>
<hr/>
 <h2><a class="anchor" id=""></a>
</h2>
<p>答案是255。</p>
<hr/>
 <h2><a class="anchor" id="找不到头文件？"></a>
找不到头文件？</h2>
<p>明明头文件的路径已经添加，并且在**QtCreator**里能够跟踪到该头文件，但是在**terminal** make的时候仍然找不到头文件？ 有一个原因：CMakeList.txt用了环境变量$ENV{}，并且QtCreator设置了这个环境变量，但是bash里面并没有设置！ 反过来，能编译，但是QtCreator老是找不到头文件，或者在QtCreator内部构建失败。</p>
<hr/>
 <h2><a class="anchor" id="获取变量的名字"></a>
获取变量的名字</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define PRINTER(name) printer(#name, (name))</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> printer(<span class="keywordtype">char</span> *name, <span class="keywordtype">int</span> value) {</div><div class="line">    printf(<span class="stringliteral">&quot;name: %s\tvalue: %d\n&quot;</span>, name, value);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[]) {</div><div class="line">    <span class="keywordtype">int</span> foo = 0;</div><div class="line">    <span class="keywordtype">int</span> bar = 1;</div><div class="line"></div><div class="line">    PRINTER(foo);</div><div class="line">    PRINTER(bar);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line">name: foo   value: 0</div><div class="line">name: bar   value: 1</div></div><!-- fragment --><hr/>
 <h2><a class="anchor" id="函数指针常量怎么定义？"></a>
函数指针常量怎么定义？</h2>
<div class="fragment"><div class="line"><span class="comment">// normal pointer to function</span></div><div class="line">int (*func)(int);</div><div class="line"></div><div class="line"><span class="comment">// pointer to const function -- not allowed</span></div><div class="line">int (<span class="keyword">const</span> *func)(int);</div><div class="line"></div><div class="line"><span class="comment">// const pointer to function. Allowed, must be initialized.          </span></div><div class="line">int (*<span class="keyword">const</span> func)(int) = some_func;</div><div class="line"></div><div class="line"><span class="comment">// Bonus: pointer to function returning pointer to const</span></div><div class="line"><span class="keywordtype">void</span> <span class="keyword">const</span> *(*func)(int);</div><div class="line"></div><div class="line"><span class="comment">// triple bonus: const pointer to function returning pointer to const.</span></div><div class="line"><span class="keywordtype">void</span> <span class="keyword">const</span> *(*<span class="keyword">const</span> func)(<span class="keywordtype">int</span>) = func.</div></div><!-- fragment --><hr/>
 <h2><a class="anchor" id="const也不是完美的常量？"></a>
const也不是完美的常量？</h2>
<p>C99中，全局变量和静态变量初始化必须使用常量，而且这个常量只能是字面上的常量，例如“1，0xff”以及枚举。 const修饰的常量是二等公民，不能用于初始化，坑了我很久。 例如 </p><div class="fragment"><div class="line"><span class="comment">// C99</span></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> a =10;</div><div class="line"><span class="keywordtype">int</span> b = a; <span class="comment">// 错误，const变量也不能用于全局变量初始化。</span></div></div><!-- fragment --><hr/>
 <h2><a class="anchor" id=""></a>
</h2>
<p>大家都知道，C++调用C语言模块很容易，就是在函数生命的地方使用#ifdef __cplusplus extern "C" #endif 包起来就行。 但是有的时候需要在C语言环境中调用C++的模块，虽然这种调用感觉很不合理，但是仍然不可避免，例如组里的顶层框架代码是C，我们自身的模块是C++，这时候必须要把C++模块塞到C模块里。 首先，c++模块头文件需要把函数声明用extern "C"包裹， 其次，c模块在调用之前，使用extern重新声明该函数，相当于声明了两遍。另外c模块绝对不要include该c++模块的头文件，否则会报错。 最后，c模块正常调用c++模块函数。</p>
<p>其实到这里，我并不太理解为什么第一步要做，如果第二步直接重新声明了c++函数，并且压根没有include c++模块的头文件，那调用过程根本和c++头文件没有关系。 然而实际测试时，如果c++头文件去掉了extern "C"，还是会出现C linkage的问题。 这说明，extern "C"的包裹，虽然只是针对声明进行的，但是它会实际影响到定义部分，会让定义部分使用C的方式生成函数符号名。 那最后留一个疑问，如果extern "C"包裹的C++函数有重载，那么会发生什么呢？</p>
<div class="fragment"><div class="line">//C++头文件 cppExample.h</div><div class="line">#ifndef CPP_EXAMPLE_H</div><div class="line">#define CPP_EXAMPLE_H</div><div class="line">extern &quot;C&quot; int add( int x, int y );</div><div class="line">#endif</div><div class="line"></div><div class="line">//C++实现文件 cppExample.cpp</div><div class="line">#include &quot;cppExample.h&quot;</div><div class="line">int add( int x, int y )</div><div class="line">{</div><div class="line">　return x + y;</div><div class="line">}</div><div class="line"></div><div class="line">/* C实现文件 cFile.c</div><div class="line">/* 这样会编译出错：#include &quot;cExample.h&quot; */</div><div class="line">extern int add( int x, int y );</div><div class="line">int main( int argc, char* argv[] )</div><div class="line">{</div><div class="line">　add( 2, 3 );</div><div class="line">　return 0;</div><div class="line">}</div></div><!-- fragment --><hr/>
 <h2><a class="anchor" id="函数指针作为函数传参"></a>
函数指针作为函数传参</h2>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> void (*callback_function)(void); <span class="comment">// type for conciseness</span></div><div class="line"></div><div class="line">callback_function disconnectFunc; <span class="comment">// variable to store function pointer type</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> D::setDisconnectFunc(callback_function pFunc)</div><div class="line">{</div><div class="line">    disconnectFunc = pFunc; <span class="comment">// store</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> D::disconnected()</div><div class="line">{</div><div class="line">    disconnectFunc(); <span class="comment">// call</span></div><div class="line">    connected = <span class="keyword">false</span>;</div><div class="line">}</div></div><!-- fragment --><hr/>
 <h2><a class="anchor" id="sizeof用于静态数组"></a>
sizeof用于静态数组</h2>
<p>sizeof变量如果用在静态数组，那么是可以得到静态数组的总长度的， </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> array[10];</div><div class="line"><span class="keyword">sizeof</span>(array); <span class="comment">// 8*10 = 80</span></div></div><!-- fragment --><hr/>
 <h2><a class="anchor" id="下采样拷贝时间"></a>
下采样拷贝时间</h2>
<p>下采样拷贝虽然点数少，但是需要多次拷贝操作，那么这种方式和全拷贝速度差异如何呢？</p>
<div class="fragment"><div class="line">uint32_t W=640, H=480, WH=W*H;</div><div class="line">FILE *f = fopen(<span class="stringliteral">&quot;img&quot;</span>,<span class="stringliteral">&quot;rb&quot;</span>);</div><div class="line">uint8_t* buf = malloc(WH);</div><div class="line">fread(buf, WH, 1, f);</div><div class="line"></div><div class="line">int64_t t = cv::getTickCount();</div><div class="line">uint8_t * img = (uint8_t*) malloc(WH);</div><div class="line">memcpy(img, buf, WH);</div><div class="line">t = cv::getTickCount() - t;</div><div class="line">cout&lt;&lt;t/cv::getTickFrenquency()&lt;&lt;endl;</div><div class="line"></div><div class="line">t = cv::getTickCount();</div><div class="line">uint32_t sd=5, Wd=W/sd, Hd=H/sd;</div><div class="line">uint8_t *img_d = (uint8_t*)malloc(Wd*Hd);</div><div class="line"><span class="keywordflow">for</span>(uint32_t r=0; r&lt;Hd; r++)</div><div class="line">  <span class="keywordflow">for</span>(uint32_t c=0; c&lt;Wd; c++)</div><div class="line">    img_d[r*Wd+c] = buf[r*sd*W+c*sd];</div><div class="line">t = cv::getTickCount()-t;</div><div class="line">cout&lt;&lt;t/cv::getTickFrequency()&lt;&lt;endl;</div></div><!-- fragment --><p>PC上运行的结果，t1是全拷贝的时间，t2是下采样拷贝的时间，可以看到在debug版本中，2倍采样和3倍采样时间都要长于全采样，直到4倍采样开始时间才小于全采样，这是因为下采样需要设计循环，依次赋值，全拷贝肯定在汇编层面做了优化的。 有意思的是在Release版本中，2倍采样的时间就小于全拷贝，这就说明debug版本对于循环有着更深的影响，下采样最大运行时间相差了接近6倍。</p>
<p>Debug版本</p>
<table class="doxtable">
<tr>
<th>sd </th><th>1   </th><th>2   </th><th>3   </th><th>4   </th><th>5   </th><th>6    </th></tr>
<tr>
<td>t1 </td><td>91.5 </td><td>90.5 </td><td>91.7 </td><td>91.2 </td><td>90.4 </td><td>90.6 </td></tr>
<tr>
<td>t2 </td><td>840 </td><td>219 </td><td>102 </td><td>60.2 </td><td>39.1 </td><td>27.6 </td></tr>
</table>
<p>Release版本</p>
<table class="doxtable">
<tr>
<th>sd </th><th>1   </th><th>2   </th><th>3   </th><th>4   </th><th>5   </th><th>6    </th></tr>
<tr>
<td>t1 </td><td>74.4 </td><td>72.7 </td><td>74.3 </td><td>74.6 </td><td>77.3 </td><td>75.1 </td></tr>
<tr>
<td>t2 </td><td>158 </td><td>62.6 </td><td>30.5 </td><td>18.5 </td><td>12.3 </td><td>8.96 </td></tr>
</table>
<p>ARM </p><table class="doxtable">
<tr>
<th>sd </th><th>1   </th><th>2   </th><th>3   </th><th>4   </th><th>5   </th><th>6    </th></tr>
<tr>
<td>t1 </td><td>644 </td><td>654 </td><td>652 </td><td>645 </td><td>670 </td><td>685 </td></tr>
<tr>
<td>t2 </td><td>667 </td><td>208 </td><td>97.6 </td><td>28.2 </td><td>69.0 </td><td>48.4 </td></tr>
</table>
<hr/>
 <h2><a class="anchor" id="图像浏览工具"></a>
图像浏览工具</h2>
<p>做图像算法的时候经常要处理图像buffer，就是最原始指针那种，因为程序运行在嵌入式平台，所以有的时候调试起来看图不是特别方便，很多时候我们从板子上存下来的图是原始的raw格式，或者我们想传入我们自己的图像进行测试，这时候就需要某种图像转换和浏览工具。</p>
<p>下面是代码，其实思路很简单，使用opencv将raw格式的文件打开，然后转换成bmp，再使用bat调用图片浏览工具，实现双击就能浏览的效果。 这里的bin格式是我自己定义的，bin表示单通道，bin3表示3通道，通常是BGR。 代码中转换单通道的函数没有填写，这里只填写了3通道的。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;opencv2/core/core.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;opencv2/highgui/highgui.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacestd.html">std</a>;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacecv.html">cv</a>;</div><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> uint8_t;</div><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> uint32_t;</div><div class="line"></div><div class="line"><span class="preprocessor">#define PRINT_AND_RETURN(x) do{cout&lt;&lt;x&lt;&lt;endl; return 1;}while(0)</span></div><div class="line"><span class="preprocessor">#define PRINT_USAGE_AND_RETURN() PRINT_AND_RETURN(&quot;Usage: bin_viewer.exe &lt;input file&gt; &lt;output file&gt;&quot;)</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> convert_bin_to_bmp(<span class="keywordtype">string</span> in_path, <span class="keywordtype">string</span> out_path)</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> convert_bin3_to_bmp(<span class="keywordtype">string</span> in_path, <span class="keywordtype">string</span> out_path)</div><div class="line">{</div><div class="line">    ifstream f;</div><div class="line">    f.open(in_path, ios::binary);</div><div class="line">    uint32_t W,H;</div><div class="line">    f.read((<span class="keywordtype">char</span>*)&amp;W, <span class="keyword">sizeof</span>(uint32_t));</div><div class="line">    f.read((<span class="keywordtype">char</span>*)&amp;H, <span class="keyword">sizeof</span>(uint32_t));</div><div class="line">    Mat save(H,W, CV_8UC3);</div><div class="line">    f.read((<span class="keywordtype">char</span>*)save.data, 3*W*H);</div><div class="line">    imwrite(out_path, save);</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">char</span> argc, <span class="keywordtype">char</span> **argv)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span>(argc&lt;3)</div><div class="line">        PRINT_USAGE_AND_RETURN();</div><div class="line"></div><div class="line">    <span class="keywordtype">string</span> in_path = string(argv[1]);</div><div class="line">    <span class="keywordflow">if</span>(in_path.substr(in_path.size()-3, 3) == <span class="stringliteral">&quot;bin&quot;</span>)</div><div class="line">        convert_bin_to_bmp(<span class="keywordtype">string</span>(argv[1]), <span class="keywordtype">string</span>(argv[2]));</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span>(in_path.substr(in_path.size()-4, 4) == <span class="stringliteral">&quot;bin3&quot;</span>)</div><div class="line">        convert_bin3_to_bmp(<span class="keywordtype">string</span>(argv[1]), <span class="keywordtype">string</span>(argv[2]));</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">        PRINT_AND_RETURN(<span class="stringliteral">&quot;only open bin or bin3 file!&quot;</span>);</div><div class="line"></div><div class="line">    cout&lt;&lt;<span class="stringliteral">&quot;done!&quot;</span>&lt;&lt;endl;</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> 接下来就是编写bat文件，调用exe、传入参数并且调用图片浏览工具。 其中%1就是传入的参数，对，没错，就是双击的文件的路径，不要怀疑，微软爸爸已经给你做好了！ 给bin文件和bin3文件选择默认的打开方式，设置成bat文件，对，就是右键选择默认程序！ ImageGlass是一个网上下载的轻量级的浏览工具。</p>
<div class="fragment"><div class="line">bin_viewer.exe %1 out.bmp</div><div class="line">&quot;C:\Program Files\ImageGlass\ImageGlass.exe&quot; out.bmp</div></div><!-- fragment --><hr/>
 <h2><a class="anchor" id="遇到unresolved"></a>
external symbol怎么办？</h2>
<p>如果这个symbol在源文件里：</p><ul>
<li>看看这个源文件有没有被加到工程中。</li>
<li>symbol在源文件中，并且已经添加到了工程，还会报这个错？看看是不是.c文件和.cpp文件互相调用了，如果互相调用，记得用EXTERN C封装。</li>
<li>都是cpp文件或者c文件，或者已经用EXTERN C封装了，还会出错？看看是不是不同源文件字符编码的问题。</li>
<li>以上条件都满足，但在qtcreator中刚添加的函数还是报这个错？那就试着显式地qmake一下，然后再rebuild。</li>
<li>如果还有问题，那我也不知道怎么办了，就把电脑砸了吧。</li>
</ul>
<p>如果这个symbol在库文件中：</p><ul>
<li>看看这个库有没有添加到工程。</li>
<li>库已经添加到工程，但是仍然报这个错？那就将库的版本和当前编译器版本保持一致，包括平台（x86或者x64）和版本（vc08，vc10，vc12，vc14）以及是否调试（debug和release）。</li>
</ul>
<hr/>
 <h2><a class="anchor" id="工程内外的头文件区别？"></a>
工程内外的头文件区别？</h2>
<p>C语言头文件不管是放在工程内部还是工程外部都可以include，那么这两种方式有什么区别呢？ 目前发现的区别有一点，就是工程内部的头文件内部再include别的头文件的时候可以享用工程文件已经添加的路径。 举个例子，a.h是工程部内的，b.h是工程外部的，main.cpp里面把这两个头文件都include了，工程pro（qtcreator）文件里包含了opencv的库目录。 那么打开a.h时输入“include &lt;opencv.....”，此时creator会自动补全，但是在b.h中输入则没有任何反应，这就是目前发现的一个区别。 但是我估计实际编译的时候应该没有问题，这只是IDE的识别问题而已。</p>
<hr/>
 <h2><a class="anchor" id=""></a>
</h2>
<p>在c文件中include Opencv的hpp头文件就会出现这个问题，因为编译c文件时是使用C编译器编译的，而.c文件是不认识.hpp文件的，实现的方式就是c编译器并未定义__cplusplus宏。按照道理说c文件不应该包含h文件，最好把c文件改成cpp文件。如果硬是不改，在VisualStudio中可以设置compile as c++。在别的环境就不知道怎么搞了。</p>
<hr/>
 <h2><a class="anchor" id="浮点转定点中的四舍五入"></a>
浮点转定点中的四舍五入</h2>
<p>浮点数转定点数不能直接截取，必须四舍五入，否则精度会丢失，有时候会丢失很多！ 例如下面的代码，将浮点数转换成16Q8的定点数，当输入0.035时，0.035*256.0=8.96，直接截取就变成了8，然而8对应着0.03125，9对应着0.03515625，很明显应该是9更合适。 我们自然而然地想到+0.5，例如第二行代码所示，但是这样仍然是有问题的，就是在使用负数的时候。 例如输入-0.6，那么照理说-0.6更接近-1，然而-0.6+0.5=-0.1会截取成0，没有错(int)(-0.1)=0，在VS下是这样的。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define Q168_FROM_FLOAT(x) ( (int16_t)((x)*256.0) ) // 丢失精度</span></div><div class="line"><span class="preprocessor">#define Q168_FROM_FLOAT(x) ( (int16_t)((x)*256.0+0.5) ) // 负数不准</span></div><div class="line"><span class="preprocessor">#define Q168_FROM_FLOAT(x) ( (int16_t)((x)&gt;=0?(x)*256.0+0.5:(x)*256.0-0.5) ) //完美</span></div><div class="line"></div><div class="line"><span class="comment">// 测试</span></div><div class="line">printf(<span class="stringliteral">&quot;%d,%d\n&quot;</span>, Q168_FROM_FLOAT(0.35), Q168_FROM_FLOAT(-0.35))</div><div class="line"><span class="comment">//结果为 9和-9，正确！</span></div></div><!-- fragment --><hr/>
 <h2><a class="anchor" id="printf"></a>
中的uint64整数</h2>
<p>使用printf过程中，一定要写对字符串，之前遇到过一个问题，使用d来打印一个int64的数是错误的，例如下列代码</p>
<div class="fragment"><div class="line">uint64_t a = 1000;</div><div class="line">printf(<span class="stringliteral">&quot;%d\n&quot;</span>,a); <span class="comment">// 错误</span></div></div><!-- fragment --><p>实际上，u，ld，lu都不对，在曾经一个ARM平台编译器上，正确的结果是llu，因为在该平台上，sizeof(long)=sizeof(int)=4，而uint64_t真正的类型是long long，在不同平台时，要注意类型字节数可能不一样。</p>
<hr/>
 <h2><a class="anchor" id="多周期算法"></a>
多周期算法</h2>
<p>两种结构：</p><ol type="1">
<li>启动计算独立</li>
<li>启动计算不独立</li>
</ol>
<hr/>
 <h2><a class="anchor" id="linux-arm-gcc"></a>
中的char默认是unsigned char!!!</h2>
<p>好可怕，给char类型变量赋值一个负数，会得到错误的结果，而且编译器不会报错或者警告 只有使用==判别时才提出警告。</p>
<div class="fragment"><div class="line">char a = -1;</div><div class="line">printf(&quot;%d\n&quot;,a );  //打印出 255</div><div class="line">if(a == -10)</div><div class="line">  printf(&quot;error&quot;) // 编译报错</div></div><!-- fragment --><hr/>
 <h2><a class="anchor" id="C语言算法中的数学参数放在哪里？"></a>
C语言算法中的数学参数放在哪里？</h2>
<p>程序运行过程中始终不变的数学常量称为参数，做算法的代码会有特别多的参数，要怎么放置这些参数呢？</p><ol type="1">
<li>直接在调用的地方用数字常量表示，例如 <div class="fragment"><div class="line">x = 0.01 *y;</div></div><!-- fragment --> 这种方式被称为magic number, 不太好。 第一，不好理解，如果只有一个number，还勉强可以注释，如果一行代码有多个number，就真的不好注释了。 第二，如果这个参数在很多地方用到，参数变动的时候，需要多处修改，非常容易有漏网之鱼。</li>
</ol>
<p>2.直接用宏来define数字，在调用的地方使用宏。 </p><div class="fragment"><div class="line"><span class="preprocessor">#define SLAM_PARA_XXXX 0.01</span></div></div><!-- fragment --><p> 这种方式比直接用数字要好，define单个数字是没问题的，但是在定义数组型参数的时候就不太方便了，例如 </p><div class="fragment"><div class="line"><span class="keywordtype">float</span> para_xxx[2][3] = {{1.0000, 2.0000, 3.0000},</div><div class="line">                        {4.0000, 5.0000, 6.0000}};</div></div><!-- fragment --><p> 一个很勉强的方式就是把宏定义成花括号里的内容，然后就在调用的地方新建一个变量=宏，但是这样很怪。。。 而且如果这个参数表很大的话，例如10x10的静态查找表，每次调用的地方新建变量并赋值一次会有很多额外消耗。</p>
<ol type="1">
<li>用全局变量直接定义 这种方式算是一种比较整洁的解决方案，但是全局变量用多了之后</li>
</ol>
<hr/>
 <h2><a class="anchor" id="一个float不够用的例子"></a>
一个float不够用的例子</h2>
<p>x = {3137995, 3137895, 3137978} A = {{x0*x0, x0, 1},{x1*x1, x1, 1},{x2*x2, x2, 1}}</p>
<hr/>
 <h2><a class="anchor" id="另一个float不够用的例子"></a>
另一个float不够用的例子</h2>
<p>以纳秒为单位UTC时间数值上特别大，举个例子（946,685,275,874,349,312，这一连串是一个数字），大概是30年左右。</p>
<hr/>
 <h2><a class="anchor" id="头文件重复包含"></a>
头文件重复包含</h2>
<p>我们都知道头文件一开始两行都是::ifndef和::define，是为了避免头文件重复包含，从逻辑上和减少编译时间看，都需要消除这种重复包含， 那么消除重复包含的工作为什么不丢给程序员做呢？</p><ol type="1">
<li>这样的工作非常枯燥而繁琐，包含的链路太长的话，光是找到公共头文件节点就很麻烦； 2.更重要的是，部分模块常常需要独立运行，这种冗余保证了模块也能够独立地运行。</li>
</ol>
<hr/>
 <h2><a class="anchor" id="extern"></a>
声明</h2>
<p>默认的全局变量都开放成全局可用变量，其他模块想用该变量只需要extern声明即可。 例如a.c文件中定义int a = 0; b.c文件中声明extern int a; 那么b文件中使用的变量其实就是a文件中的变量 **a.c文件和b.c文件不需要什么相互依赖的关系，也和头文件无关**。 但是一般来说，在a.h中声明extern int a;然后b.c文件再include a.h文件，这样的用法会比较规范。</p>
<hr/>
 <h2><a class="anchor" id="全局变量用处"></a>
全局变量用处</h2>
<p>1.静态表格常量 2.调试系统</p>
<p>调试系统是反封装的，调试系统往往需要获取某些很深的函数内部的某些中间变量，如果通过传参获取， （1）那么函数参数就会很多， （2）调试系统需要查看的变量集可能会经常变化，层层递归修改函数形参</p>
<hr/>
 <h2><a class="anchor" id=""></a>
</h2>
<p>将在线代码分离成离线代码的时候，发现有些文件里面定义了_Bool类型，而gcc编译器居然不识别。 Google后发现，_Bool类型是C语言的布尔类型，从C99才开始引入的。 C99以前的C语言都是用int或者枚举的野路子来表示布尔型。。。 我们平时用的bool都是C++的东西。。。 也就是说如果在 extern "C"中间使用bool，是不被支持的，除非引用了头文件stdbool.h</p>
<hr/>
 <h2><a class="anchor" id="将指针赋值给uint32_t"></a>
将指针赋值给uint32_t</h2>
<p>很多32位平台的程序喜欢使将指针赋值给整数，这样就不需要二级指针，例如</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> func(uint32_t *addr)</div><div class="line">{</div><div class="line">  <span class="keywordtype">void</span> * data = malloc (1000);</div><div class="line">  *addr = (uint32_t) data;</div><div class="line">}</div></div><!-- fragment --><p> 如果需要在函数里面开内存，输出内存地址，那么要么使用二级指针，要么用这种转地址的方式。 但是，这种方式其实并不好，在64位系统中，指针的大小可能是64位的，这样赋值就会出错。 仍然像想用这种方式的话，使用intptr_t类型，兼容32和64位，在C99中支持，在&lt;stdint.h&gt;中定义。</p>
<hr/>
 <h2><a class="anchor" id="designated"></a>
initializer</h2>
<p>C语言中结构体在C99中的一种新的初始化语法，叫做designated initializer，即指定初始化，之前我一直找不到正式的名称，我一直称之为点变量初始化。。。</p>
<div class="fragment"><div class="line">MY_TYPE a = { .flag = <span class="keyword">true</span>, .value = 123, .stuff = 0.456 };</div></div><!-- fragment --><p> 这个东西与编译器无关，是C99的标准，gcc想用的话必须开启选项 -std=c99</p>
<p>如果使用qtcreator构建工程，那么默认使用g++编译，然而如果designated initializer语句是在cpp文件里，g++是不支持的，不管CXX_FLAG 是不是加了c++11，或者C_FLAG 加了99，或者加入extern "C"，都不行， extern "C"只是指示c++编译器把函数编成C语言可识别的符号表，并不支持这种赋值语法。</p>
<p>但是我发现了一种方法，就是强行改cpp后缀为c，这样g++就会调用gcc来编译c文件。</p>
<hr/>
 <h2><a class="anchor" id="代码区分不同操作系统"></a>
代码区分不同操作系统</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#ifdef __linux__ </span></div><div class="line">    <span class="comment">//linux code goes here</span></div><div class="line"><span class="preprocessor">#elif _WIN32</span></div><div class="line">    <span class="comment">// windows code goes here</span></div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    cout&lt;&lt;<span class="stringliteral">&quot;OS not supported!&quot;</span>&lt;&lt;endl;</div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><hr/>
 <h2><a class="anchor" id="utf-8文件的bom字节"></a>
utf-8文件的bom字节</h2>
<p>很蛋疼，读utf-8文件前面3个字节都不是文件中的内容，而是0xef,0xbb,0xbf，后来一查，发现这是utf-8文件的bom字节，就是byte order mark, 读utf-8文件时，一定要去掉前面三个字节。</p>
<hr/>
 <h2><a class="anchor" id="utf-8文件中的行结尾"></a>
'\r'</h2>
<p>很蛋疼+1，读utf-8文件的时候，行结尾都是以''结束， 当文件内容是另一个文件的路径的时候，例如 </p><div class="fragment"><div class="line">/mnt/cc/随便</div></div><!-- fragment --><p> 其实这一行读出来是这样的 </p><div class="fragment"><div class="line">&#39;/&#39;,&#39;m&#39;,&#39;,&#39;t&#39;,&#39;/&#39;,&#39;c&#39;,&#39;c&#39;,&#39;/&#39;,&#39;随,&#39;便&#39;,\r</div></div><!-- fragment --><p> 我一般喜欢在文件路径后面加上'/'，方便后面读取。 但是如果在后面加上'/'就会搞错。。</p>
<hr/>
 <h2><a class="anchor" id="qtcreator中开启gcc的c99支持"></a>
qtcreator中开启gcc的c99支持</h2>
<div class="fragment"><div class="line">QMAKE_CFLAGS += -std=c99</div></div><!-- fragment --><hr/>
 <h2><a class="anchor" id="printf"></a>
中的uint64整数</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include&lt;stdarg.h&gt;</span></div><div class="line">...</div><div class="line">void printf_red(<span class="keyword">const</span> <span class="keywordtype">char</span> *cmd, ...)  </div><div class="line">{  </div><div class="line">    printf(<span class="stringliteral">&quot;\x1B[31m&quot;</span>);  <span class="comment">//设置输出为红色</span></div><div class="line">    va_list args;       <span class="comment">//定义一个va_list类型的变量，用来储存单个参数  </span></div><div class="line">    va_start(args,cmd); <span class="comment">//使args指向可变参数的第一个参数  </span></div><div class="line">    vprintf(cmd,args);  <span class="comment">//必须用vprintf等带V的  </span></div><div class="line">    va_end(args);       <span class="comment">//结束可变参数的获取  </span></div><div class="line">    printf(<span class="stringliteral">&quot;\x1B[0m&quot;</span>)   <span class="comment">// 回到默认设置</span></div><div class="line">}  </div></div><!-- fragment --><hr/>
 <h2><a class="anchor" id="规范打印"></a>
规范打印</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#indef PRINT_ERROR</span></div><div class="line"><span class="preprocessor">#define PRINT_ERROR(...)    \</span></div><div class="line"><span class="preprocessor">  do{                       \</span></div><div class="line"><span class="preprocessor">    printf(&quot;\x1B[41;37m&quot;);  \</span></div><div class="line"><span class="preprocessor">    printf(&quot;[ERROR]&quot;);      \</span></div><div class="line"><span class="preprocessor">    printf(&quot;\x1B[0m&quot;);      \</span></div><div class="line"><span class="preprocessor">    printf(__VA_ARGS__);    \</span></div><div class="line"><span class="preprocessor">    }                       \</span></div><div class="line"><span class="preprocessor">  while(0)</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#ifndef PRINT_INFO</span></div><div class="line"><span class="preprocessor">#define PRINT_INFO(...)     \</span></div><div class="line"><span class="preprocessor">  do{                       \</span></div><div class="line"><span class="preprocessor">    printf(&quot;\1xB[42;37m&quot;);  \</span></div><div class="line"><span class="preprocessor">    printf(&quot;[INFO] &quot;);      \</span></div><div class="line"><span class="preprocessor">    printf(__VA_ARGS__);    \</span></div><div class="line"><span class="preprocessor">    }                       \</span></div><div class="line"><span class="preprocessor">  while(0)</span></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><hr/>
 <h2><a class="anchor" id="重复定义"></a>
重复定义</h2>
<p>如果发现某个变量明明只有一处，但是编译器老是提出重复定义，就要看看头文件是否没有写::ifndef #define #endif三连。</p>
<hr/>
 <h2><a class="anchor" id=""></a>
</h2>
<p>很有可能的原因是： 在头文件中定义了变量和函数，这会导致头文件被多个c文件引用，h文件里的变量和函数就会出现在多个.o文件中，最后链接的时候出现错误。</p>
<hr/>
 <h2><a class="anchor" id="二维数组的传参和“引用”"></a>
二维数组的传参和“引用”</h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> func_a(<span class="keywordtype">int</span> a[][10])</div><div class="line">{</div><div class="line">...</div><div class="line">}</div><div class="line"><span class="comment">// 或者</span></div><div class="line"><span class="keywordtype">void</span> func_b(<span class="keywordtype">int</span> (*a)[10])</div><div class="line">{</div><div class="line">...</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordtype">int</span> a[5][10];</div><div class="line">  int (*b)[10] = a;</div><div class="line">}</div></div><!-- fragment --><p> 注意：第二种方式中的<code>*b</code>必须使用括号括起来，否则就变成了一维的数组指针了。</p>
<hr/>
 <h2><a class="anchor" id="No"></a>
rules to make target</h2>
<p>这个提示表示编译模块时时找不到源代码，检查一下C和C++文件是否在构建脚本中添加进去了。</p>
<hr/>
 <h2><a class="anchor" id="使用enum代替整数的好处"></a>
使用enum代替整数的好处</h2>
<p>防止数组访问溢出 假设在函数func里操作一个size为N的数组，函数传入需要操作的index，那么在没有前置判断溢出的情况下，需要加入判断是否溢出的语句。 </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> a[10]</div><div class="line"><span class="keywordtype">int</span> func(<span class="keywordtype">int</span> x)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span>(x&gt;=10)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line">  printf(<span class="stringliteral">&quot;%d&quot;</span>,a[x]);</div><div class="line">}</div></div><!-- fragment --><p> 如果数组的size不大，而且具有明确的含义，例如某种过程处理通道的个数，可以考虑使用枚举来代替。 使用枚举的好处是，枚举变量一定不会超出定义域的范围，在编译阶段就决定了不会产生数组的越界。</p>
<hr/>
 <h2><a class="anchor" id=""></a>
</h2>
<p>定义全局的static const char*`字符串会提示变量定义但未使用。 原因是未解之谜，可以考虑换种方法。 </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> * a = <span class="stringliteral">&quot;abcdef&quot;</span>; <span class="comment">//有问题</span></div><div class="line"><span class="keyword">static</span> cosnt <span class="keywordtype">char</span> a[] = <span class="stringliteral">&quot;abcdef&quot;</span>; <span class="comment">//OK</span></div></div><!-- fragment --><hr/>
 <h2><a class="anchor" id="运算符优先级cheatsheet"></a>
运算符优先级cheatsheet</h2>
<table class="wikitable">
</table>
<p>优先级  </p>
<p>运算符  </p>
<p>描述  </p>
<p>结合性  </p>
<p>1  </p>
<p><code>++</code> <code>&ndash;</code>  </p>
<p>后缀自增与自减  </p>
<p>从左到右  </p>
<p><code>()</code>  </p>
<p>函数调用  </p>
<p><code>[]</code>  </p>
<p>数组下标  </p>
<p><code>.</code>  </p>
<p>结构体与联合体成员访问  </p>
<p><code>-&gt;</code>  </p>
<p>结构体与联合体成员通过指针访问  </p>
<p><code>(<em>type</em>){<em>list</em>}</code>  </p>
<p>复合字面量<span class="t-mark">(C99)</span>  </p>
<p>2  </p>
<p><code>++</code> <code>&ndash;</code>  </p>
<p>前缀自增与自减<sup id="cite_ref-1" class="reference"><a href="#cite_note-1">[注 1]</a></sup>  </p>
<p>从右到左  </p>
<p><code>+</code> <code>-</code>  </p>
<p>一元加与减  </p>
<p><code>!</code> <code>~</code>  </p>
<p>逻辑非与逐位非  </p>
<p><code>(<em>type</em>)</code>  </p>
<p>类型转型  </p>
<p><code>*</code>  </p>
<p>间接（解引用）  </p>
<p><code>&amp;</code>  </p>
<p>取址  </p>
<p><code>sizeof</code>  </p>
<p>取大小<sup id="cite_ref-2" class="reference"><a href="#cite_note-2">[注 2]</a></sup>  </p>
<p><code>_Alignof</code>  </p>
<p>对齐要求<span class="t-mark">(C11)</span>  </p>
<p>3  </p>
<p><code>*</code> <code>/</code> <code>%</code>  </p>
<p>乘法、除法及余数  </p>
<p>从左到右  </p>
<p>4  </p>
<p><code>+</code> <code>-</code>  </p>
<p>加法及减法  </p>
<p>5  </p>
<p><code>&lt;&lt;</code> <code>&gt;&gt;</code>  </p>
<p>逐位左移及右移  </p>
<p>6  </p>
<p><code>&lt;</code> <code>&lt;=</code>  </p>
<p>分别为 &lt; 与 ≤ 的关系运算符  </p>
<p><code>&gt;</code> <code>&gt;=</code>  </p>
<p>分别为 &gt; 与 ≥ 的关系运算符  </p>
<p>7  </p>
<p><code>==</code> <code>!=</code>  </p>
<p>分别为 = 与 ≠ 关系  </p>
<p>8  </p>
<p><code>&amp;</code>  </p>
<p>逐位与  </p>
<p>9  </p>
<p><code>^</code>  </p>
<p>逐位异或（排除或）  </p>
<p>10  </p>
<p><code>|</code>  </p>
<p>逐位或（包含或）  </p>
<p>11  </p>
<p><code>&amp;&amp;</code>  </p>
<p>逻辑与  </p>
<p>12  </p>
<p><code>||</code>  </p>
<p>逻辑或  </p>
<p>13  </p>
<p><code>?:</code>  </p>
<p>三元条件<sup id="cite_ref-3" class="reference"><a href="#cite_note-3">[注 3]</a></sup>  </p>
<p>从右到左  </p>
<p>14<sup id="cite_ref-4" class="reference"><a href="#cite_note-4">[注 4]</a></sup>  </p>
<p><code>=</code>  </p>
<p>简单赋值  </p>
<p><code>+=</code> <code>-=</code>  </p>
<p>以和及差赋值  </p>
<p><code>*=</code> <code>/=</code> <code>%=</code>  </p>
<p>以积、商及余数赋值  </p>
<p><code>&lt;&lt;=</code> <code>&gt;&gt;=</code>  </p>
<p>以逐位左移及右移赋值  </p>
<p><code>&amp;=</code> <code>^=</code> <code>|=</code>  </p>
<p>以逐位与、异或及或赋值  </p>
<p>15  </p>
<p><code>,</code>  </p>
<p>逗号  </p>
<p>从左到右 &lt;/tbody&gt;</p>
<hr/>
 <h1><a class="anchor" id="GCC"></a>
编译(链接）报错指南</h1>
<hr/>
 <h2><a class="anchor" id="undefined"></a>
reference</h2>
<p>1.（初级）变量或者函数没有定义 2.（初级）变量或者函数所在的源文件没有加入到编译配置里</p>
<hr/>
 <h2><a class="anchor" id="multiple"></a>
definition?</h2>
<p>1.（初级）在多个源文件中定义了相同的非static函数或者非static变量。 2.（初级）Coding层面上确实只定义了一个变量，但是这个变量定义在头文件中，而且是非static的，一旦有多个源文件包含这个头文件，这一个变量就会变成多个。 3.（中级）不同的lib或者exe编译了同一个源文件，而且.o文件放在了不同的目录，Linker会发现多个同名.o文件，自然里面的变量也会重复定义。</p>
<hr/>
 <h2><a class="anchor" id="怎样printf"></a>
size_t类型才不会报warning</h2>
<div class="fragment"><div class="line"><span class="comment">// C89</span></div><div class="line"><span class="keywordtype">size_t</span> foo;</div><div class="line">...</div><div class="line">printf(<span class="stringliteral">&quot;foo = %lu\n&quot;</span>, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) foo);</div><div class="line"><span class="comment">// For C99 and later, use %zu:</span></div><div class="line"></div><div class="line"><span class="keywordtype">size_t</span> foo;</div><div class="line">...</div><div class="line">printf(<span class="stringliteral">&quot;foo = %zu\n&quot;</span>, foo);</div></div><!-- fragment --><hr/>
 <h1><a class="anchor" id="判断数字是否是nan"></a>
判断数字是否是nan</h1>
<p>isnan()函数。 </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <ul>
    <li class="navelem"><a class="el" href="zk_note.html">学习笔记</a></li><li class="navelem"><a class="el" href="programming.html">编程</a></li>
    <li class="footer">
      <span id="busuanzi_container_site_pv">
        本站总访问量<span id="busuanzi_value_site_pv"></span>次
    </span>
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
