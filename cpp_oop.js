var cpp_oop =
[
    [ "C++中的类和对象", "cpp_class.html", [
      [ "基类和派生类的构造与析构函数执行顺序是什么？", "cpp_class.html#基类和派生类的构造与析构函数执行顺序是什么？", null ],
      [ "引用作为类的成员变量", "cpp_class.html#引用作为类的成员变量", null ],
      [ "匿名struct和匿名union", "cpp_class.html#匿名struct和匿名union", null ]
    ] ],
    [ "C++中的构造函数与析构函数", "cpp_constructor.html", [
      [ "容器成员变量是否会随着父类的析构而清空？", "cpp_constructor.html#容器成员变量是否会随着父类的析构而清空？", null ],
      [ "构造函数的参数隐式转换为对象", "cpp_constructor.html#构造函数的参数隐式转换为对象", null ]
    ] ],
    [ "C++中的多态", "cpp_polymorphism.html", [
      [ "C++中的override关键字有什么作用？", "cpp_polymorphism.html#keyword_override", null ],
      [ "多态中为何需要将析构函数设置为virtual类型？", "cpp_polymorphism.html#virtual_deconstructor", null ],
      [ "如何优雅地定义没有成员函数的类型为虚类？", "cpp_polymorphism.html#如何优雅地定义没有成员函数的类型为虚类？", null ],
      [ "如何优雅的拷贝虚类对象？", "cpp_polymorphism.html#如何优雅的拷贝虚类对象？", null ],
      [ "抽象类的构造函数不能运行成员虚成员函数", "cpp_polymorphism.html#抽象类的构造函数不能运行成员虚成员函数", null ],
      [ "重写(override)父类的重载(overload)函数", "cpp_polymorphism.html#override_overload", null ],
      [ "重写函数可以子类型", "cpp_polymorphism.html#重写函数可以子类型", null ],
      [ "基于基类指针获取子类的size？", "cpp_polymorphism.html#基于基类指针获取子类的size？", null ]
    ] ]
];