<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>一个普通的笔记本: C++构建报错合集</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax:{
        inlineMath: [["\\(", "\\)"]],
        displayMath: [['$$','$$'],["\\[","\\]"]],
        processEscapes: true
    },
    "HTML-CSS": {fonts: ["TeX"]},
    TeX: {
        extensions: ["AMSmath.js", "AMSsymbols.js", "noErrors.js", "noUndefined.js"],
        equationNumbers: {autoNumber: "all"},
    }
});
</script><script type="text/javascript" src="./MathJax-2.7.8/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('cpp_build_errors.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">C++构建报错合集 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="编译篇"></a>
编译篇</h1>
<h2><a class="anchor" id="no_rule_to_make"></a>
No rule to make xxx.cpp 或者 xxx.so</h2>
<ul>
<li>如果提示无法make cpp源文件，那么一般情况是找不到在CMakeLists.txt中列出的文件，检查一下路径和文件名即可。</li>
<li>如果提示无法make xxx.so文件，特别是找不到第三方库，例如/usr/lib/xxx.so之类的，一般都是cmake缓存出现了问题，清空cmake缓存（删除CMakeCache.txt,CMakeFiles,MakeFile,cmake_install.cmake这几个文件）。</li>
</ul>
<h2><a class="anchor" id="discards_qualifiers"></a>
passing ‘const xxx’ as ‘this’ argument discards qualifiers</h2>
<p>首先确认一点，什么是“qualifiers”？ 注意，通常来说，使用英文来表达的对象，含义都很明确 “qualifiers”表示类型的修饰符，它目前只包含这三种：</p>
<ul>
<li>const，也就是我们常说的常量修饰符</li>
<li>volatile，用的比较少，表示修饰的变量在后面随时会改变，强制编译器使用变量地址数据，否则编译器会自行根据代码情况进行优化，例如基于寄存器缓存。具体使用场景自行探索。</li>
<li>mutable，用的也比较少，根据cppreference的定义，用mutable定义的成员变量，那么它是可以改变的，即使其container是const的！似乎破坏了const的法则，具体使用场景自行探索。</li>
</ul>
<p>所以说，如果错误提示出现了“qualifiers”相关的内容，那么一定就上述几个修饰符的问题。第二个和第三个修饰符很少用，那么一般情况下，都是const的问题。 “discards qualifiers”表示丢弃了修饰符，咋一看不太懂，实际上它表达的是在函数传递的过程中修饰符被丢弃了，或者函数内部出现了矛盾现象。</p>
<p>举个最常见的例子，下面代码展示了一个案例，试图定义一个二维向量类，通过x()和y()访问具体分量，注意这些接口是可以修改成员变量的，因为返回的是引用。 但是在企图通过add()函数将两者相加时，传入的是const的父对象，这时一个const对象调用一个可以修改对象成员变量的成员函数，即x()和y()，就是矛盾，最终导致报错。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cstdio&gt;</span></div><div class="line"><span class="keyword">struct </span>Vec{</div><div class="line">    <span class="keywordtype">int</span> data[2];</div><div class="line">    <span class="keywordtype">int</span> &amp; x(){</div><div class="line">        <span class="keywordflow">return</span> data[0];</div><div class="line">    }</div><div class="line">    <span class="keywordtype">int</span> &amp; y(){</div><div class="line">        <span class="keywordflow">return</span> data[1];</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line">Vec add(<span class="keyword">const</span> Vec&amp; a, <span class="keyword">const</span> Vec&amp;b){</div><div class="line">    Vec s;</div><div class="line">    s.x() = a.x() + b.x();  <span class="comment">// a和b是const的，但是x()和y()接口是可以修改成员变量的。</span></div><div class="line">    s.y() = a.y() + b.y();</div><div class="line">    <span class="keywordflow">return</span> s;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    Vec a,b,c;</div><div class="line">    a.x() = 1;</div><div class="line">    a.y() = 2;</div><div class="line">    b.x() = 3;</div><div class="line">    b.y() = 4;</div><div class="line">    c = add(a,b);</div><div class="line">    </div><div class="line">    printf(<span class="stringliteral">&quot;a+b=(%d,%d)\n&quot;</span>, c.x(),c.y());</div><div class="line">}</div></div><!-- fragment --><p>编译报错： </p><div class="fragment"><div class="line"> In function &#39;Vec add(const Vec&amp;, const Vec&amp;)&#39;:</div><div class="line">14:17: error: passing &#39;const Vec&#39; as &#39;this&#39; argument of &#39;int&amp; Vec::x()&#39; discards qualifiers [-fpermissive]</div><div class="line">14:25: error: passing &#39;const Vec&#39; as &#39;this&#39; argument of &#39;int&amp; Vec::x()&#39; discards qualifiers [-fpermissive]</div><div class="line">15:17: error: passing &#39;const Vec&#39; as &#39;this&#39; argument of &#39;int&amp; Vec::y()&#39; discards qualifiers [-fpermissive]</div><div class="line">15:25: error: passing &#39;const Vec&#39; as &#39;this&#39; argument of &#39;int&amp; Vec::y()&#39; discards qualifiers [-fpermissive]</div></div><!-- fragment --><p>实际上，线性代数代码库Eigen存在同样的“问题”，如果传入一个const修饰的Vector，那么调用x()或者其他类似接口时，同样会报这个错误。 产生这个“问题”的原因是我们试图通过一个接口既能读数据，又能写数据，并且还想传入的父对象是const修饰的，其中写数据和const父对象产生了矛盾。</p>
<p>解决的方法可以和Eigen一样，不要使用const修饰父对象，或者关于变量的读和写接口分开，例如getX()，setX()等等。 对于向量的设计这个案例，我选择和Eigen一样，毕竟x()和y()这种分量在数学表达中要大量重复使用，getX()和setX()这些接口，明显太啰嗦。</p>
<h2><a class="anchor" id="memcpy_overflow"></a>
will always overflow destination buffer.</h2>
<p>gcc编译memcpy的时候，如果目标地址是一个固定大小的静态的数组，那么编译器会检查copy的size是否会超过这块静态数组的大小，超出了就会报出错误，不得不说编译器做得非常不错。</p>
<h2><a class="anchor" id="ref_deleted_func"></a>
Attempting to refer a deleted function</h2>
<p>这里的deleted表示构造函数被delete掉了。</p>
<p>这个问题常常出现在使用std::fstream时，fstream类的构造函数只允许传入引用而不允许拷贝。 如果将ifstream或者ofstream对象作为参数传入函数，那么传入时，一定要使用引用方式，否则就会报出这个错误。 这个报错没那么直接，编译器不会是说没有用传入，而是在函数调用的时候说调用的函数是被删除过的。</p>
<h2><a class="anchor" id="template_c_linkage"></a>
Template with C linkage</h2>
<p>extern C 封装起来的代码包含C++的template特性。</p>
<h2><a class="anchor" id="request_for_member"></a>
request for member xxx in something not a structure or union</h2>
<p>本身的含义是使用“.xxx”表达式时，“.”前面的的内容不是一个结构体或者联合。 具体可能出现的场景：</p>
<p>1.指针错误的使用了“.”来访问成员。 2.C99中使用designated initializer时，有成员没有逗号，在git解决冲突的时候常常遇到这个问题。</p>
<p>struct A{int a, int b}; A x = { a = 10 // 解冲突时忘记了逗号， b = 20, </p>
<h2><a class="anchor" id="extra_qualification"></a>
extra qualification</h2>
<p>qualification是指双冒号符“::”，而“extra qualification”则一般出现在类中函数定义的时候重复用“类名::函数名”进行时声明。</p>
<h2><a class="anchor" id="error_jump_to_case_label"></a>
Error: Jump to case label.</h2>
<p>报错提示：</p>
<div class="fragment"><div class="line">Error: Jump to case label, crosses initialization of xxx</div></div><!-- fragment --><p>原因，不同的case之间定义相同名称的变量。</p>
<h2><a class="anchor" id="cpp_comp_issue_01"></a>
error: new types may not be defined in a return type</h2>
<p>结构体、联合体定义的时候结尾忘记加“;”就会出现该报错。</p>
<h2><a class="anchor" id="undefined_vtable"></a>
undefined reference to `vtable for xxx'</h2>
<p>字面上的意思是找不到虚函数表，可能的原因是：</p>
<ol type="1">
<li>带有虚函数的基类的析构函数没有设置为virtual，原因参见 virtual_desctructor 。</li>
</ol>
<h2><a class="anchor" id="does_not_name_type"></a>
'xxx' does not name a type</h2>
<p>表示没有该符号类型没有定义，一般来原因有可能是</p>
<ol type="1">
<li>名称拼写错误</li>
<li>头文件未包含</li>
<li>命名空间不正确</li>
</ol>
<h2><a class="anchor" id="expect_class_name"></a>
error: expected class-name before ‘{’ token</h2>
<p>字面意思是在“{”字符前面的必须是一个类名称，一般来说原因有可能是</p>
<ol type="1">
<li>名称拼写错误</li>
<li>头文件未包含</li>
<li>命名空间不正确</li>
</ol>
<h2><a class="anchor" id="invalid_new_abstract"></a>
error: invalid new-expression of abstract class type ‘xxx’</h2>
<h2><a class="anchor" id="invalid_operand"></a>
error: invalid operands of types ‘&lt;unresolved overloaded function type&gt;’ and ‘int’ to binary ‘operator&lt;’</h2>
<p>可能的原因是：</p>
<ol type="1">
<li>调用Eigen库中的带模板的Matrix&lt;T,x,x&gt;::block，解决方法参见： <a class="el" href="cpp_lib_eigen.html#block_with_template">Mat::block()与模板类的组合使用方法</a> 。</li>
</ol>
<h2><a class="anchor" id="non_class_type"></a>
error: request for member ‘x’ in ‘yyy’, which is of non-class type ‘zzz’</h2>
<h2><a class="anchor" id="lvalue_operand"></a>
error: lvalue required as left operand of assignment</h2>
<p>字面含义是等号的左边必须是左值，不能是右值，一般很明显的右值（例如常量，返回值）我们是会避免的，但是有时候就不是很明显。</p>
<ol type="1">
<li>Eigen中使用auto定义变量，发现得到的变量竟然是右值，而使用类名定义，得到的才是左值，具体参见 <a class="el" href="cpp_lib_eigen.html#eigen_auto">使用auto定义Eigen相关的变量得到右值？</a></li>
</ol>
<h2><a class="anchor" id="lvalue_bind"></a>
cannot bind non-const lvalue reference of type ‘int&amp;’ to an rvalue of type ‘int’</h2>
<p>试图将非常量左值引用绑定右值，显然是错误的，如下代码所示。稍微白话解释一下，“bind A to B”中的“A”是引用，“B”才是变量。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cstdio&gt;</span></div><div class="line"><span class="keywordtype">void</span> func_add(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b, <span class="keywordtype">int</span>&amp; c) {</div><div class="line">    c = a+b;</div><div class="line">}</div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="keywordtype">int</span> x=1,y=2;</div><div class="line">    <span class="keywordtype">float</span> z;</div><div class="line">    func_add(x,y,(<span class="keywordtype">int</span>)z); <span class="comment">//编译报错</span></div><div class="line">}</div></div><!-- fragment --><p>c和c++中存在所谓的临时变量，想到的就三种：1.运算表达式，2.类型转换，3.函数返回值。 这三种临时变量传入以非常量引用为形参的函数时，是非法的，例如：</p>
<p>临时变量无法作为非常量引用的原因是很显然的，作为非常量引用，用户肯定是希望改动这个输入参数，然而实际上真正发生改动的是临时变量。 如果编译不报错，那么可能会给使用者造成很大的误解，使用者很可能要debug很久才能发现这个问题。于是编译器就负责的直接给出编译错误。</p>
<p>实际使用的一个案例就是，使用指针的引用作为形参，通常我们想通过一个函数修改指针的指向，可以使用二级指针，也可以使用指针的引用，既然c++提倡使用引用作为输出，我这里也使用指针的引用作为输出。 使用指针的引用有一个问题就是，通常我们传入指针的时候需要做类型转换，而类型转换就是上文说道的第二种临时变量，编译器会报错。正确的使用方法就是调用时提前把指针手动转换好，再传入函数。</p>
<h2><a class="anchor" id="no_declar"></a>
error: ‘setX’ was not declared in this scope, and no declarations were found by argument-dependent lookup at the point of instantiation [-fpermissive]</h2>
<p>字面含义是没有声明对应的符号。</p>
<ol type="1">
<li>派生类构造函数调用基类的成员函数，参考 <a class="el" href="cpp_class.html#base_member_in_constructor">派生类构造函数中不能调用基类成员函数</a></li>
</ol>
<h2><a class="anchor" id="cap_non_var"></a>
capture of non-variable &lt;name&gt;</h2>
<ol type="1">
<li>试图用错误的方法捕获类成员变量，例如“[成员变量]”或者“[&amp;成员变量]”，应该使用“[=]”来（可修改地）捕获成员变量，使用“[=m]”来（不可修改地）捕获成员变量。</li>
</ol>
<h1><a class="anchor" id="链接篇"></a>
链接篇</h1>
<h2><a class="anchor" id="cpp_undefined_reference"></a>
undefined reference to `xxx'</h2>
<p>报错的字面含义是链接时找不到对应的符号，符号有可能是变量或者函数，其原因有以下可能。</p>
<ol type="1">
<li>被调用的符号声明了，但是没有定义，或者出现拼写错误导致声明和定义名称不相同。</li>
<li>对于类的static成员，需要在class体外部显示定义，参考 <a class="el" href="cpp_class.html#cpp_class_static_member">类中的静态成员变量的定义</a></li>
</ol>
<h2><a class="anchor" id="unresolved_symbol"></a>
error LNK2019: unresolved external symbol "xxx"</h2>
<p>和undefined reference是一样的，只不过是换成了VC编译器的提示。这里说一个使用VC编译器会触发该报错的原因：</p>
<p>在VS下，函数明明存在为什么还是报出unresolved symbol错误?可能是字符集问题！ 特别是将不同操作系统下的文件进行混用的时候！通通，通通，通通改成多字节字符。</p>
<p>在VS环境下，下如果是main.cpp、a.h和a.c这种组合一定会出问题，可以试一试。 注意，这里a.c是C语言写的，用于板子上的程序，不能有c++的特性，但是main.cpp可以，因为会用到第三方库进行显示，例如用Opencv读取、显示和保存图片。 解决方法，在project property的C++/Advanced中，Complie as一项从default改成as c++。 在QtCreator下也是一样的，需要设置编译方式为C++</p>
<p>另外，这个问题怎么google？一查unresolved symbol全都是确实没有添加函数定义的。</p>
<p>回答：搜索关键词：function do exist unresolved symbol</p>
<h2><a class="anchor" id="cpp_multiple_def"></a>
multiple definition of `xxx'</h2>
<p>报错的字面含义是出现了多个相同的符号，明明只定义了1处变量，但是为何多个obj文件会重复定义？</p>
<ol type="1">
<li>确实出现了同名的函数或者变量的定义。</li>
<li>确认没有同名符号，但是变量或者函数定义在了h文件中，并且没有使用static修饰，编译多个源文件，这些源文件把头文件包含后，出现了多重定义的错误。</li>
</ol>
<h2><a class="anchor" id="pthread_dso_missing"></a>
libpthread.so.0: error adding symbols: DSO missing from command line</h2>
<p>在target_link_library中添加pthread即可</p>
<div class="fragment"><div class="line">target_link_library(exe</div><div class="line">    pthread</div><div class="line">    )</div></div><!-- fragment --><h2><a class="anchor" id="thread_not_member_boost"></a>
error 'thread' is not a member of 'boost'</h2>
<p>CMakeLists.txt中添加</p>
<div class="fragment"><div class="line">target_link_library(exe</div><div class="line">        boost_thread</div><div class="line">    )</div></div><!-- fragment --><p>源代码中添加</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;boost/thread.hpp&gt;</span></div></div><!-- fragment --><h2><a class="anchor" id="undefined_static"></a>
undefined reference to `类名::count'</h2>
<p>static类成员变量在类中只是进行了声明，没有定义，而普通成员变量在生成定义对像的时候进行了定义。 所以类成员变量需要而外定义。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cstdio&gt;</span></div><div class="line"><span class="keyword">class </span>A{</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">    A(){}</div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">int</span> count;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> A::count = 0;   <span class="comment">//必须在外面进行定义，否则编译器会提示未定义</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>){</div><div class="line">    A a;</div><div class="line">    printf(<span class="stringliteral">&quot;%d\n&quot;</span>,a.count);</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="运行篇"></a>
运行篇</h1>
<h2><a class="anchor" id="bad_alloc"></a>
terminate called after throwing an instance of 'std::bad_alloc'</h2>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <ul>
    <li class="navelem"><a class="el" href="zk_note.html">学习笔记</a></li><li class="navelem"><a class="el" href="programming.html">编程（Programming）</a></li><li class="navelem"><a class="el" href="cpp.html">C++：青出于蓝，我斑愿称之为最强！</a></li>
    <li class="footer">
      <span id="busuanzi_container_site_pv">
        本站总访问量<span id="busuanzi_value_site_pv"></span>次
    </span>
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
